## 封装 继承 多态
## 遵循原则
![](https://cdn.nlark.com/yuque/0/2024/png/40370394/1730854200251-125149f1-810a-48b4-9ba0-79bfc2411e4e.png)

## 结构型模式（7）：设计类
结构型设计模式主要关注对象组合的方式，用于描述如何将类或对象结合在一起形成更大的结构。

### 适配器模式<font style="color:rgb(51, 51, 51);">（Adapter Pattern）</font>
<font style="color:rgb(51, 51, 51);">将一个类的接口转换成客户希望的另一个接口，使原本不兼容的类可以一起工作。</font>

> <font style="color:rgb(51, 51, 51);">适配器类充当了一个中间层，分为类适配器和对象适配器两种类型。类适配器使用继承来适配对象，而对象适配器使用组合来适配对象。</font>
>

### 桥接模式（Bridge Pattern）
将抽象部分与它的实现部分分离，使它们可以独立地变化。

> 在桥接模式中，存在两个独立的继承层次结构：抽象部分和实现部分。抽象部分定义了对象的接口，而实现部分则负责具体的实现。桥接模式通过将抽象部分与实现部分解耦，使得它们可以独立地变化，从而可以灵活地组合不同的抽象部分和实现部分。
>

### 装饰模式（Decorator Pattern）
动态地给一个对象添加一些额外的职责，而不影响原有对象的结构。

> 允许向对象动态地添加额外的功能，而无需修改其原始代码。装饰者模式通过创建一个装饰者类，该类包装原始对象，并在不改变其接口的情况下，扩展其功能。
>

> 在装饰者模式中，有四个关键角色：
>
> 1. 抽象组件（Component）：定义了一个抽象接口，可以是一个接口或者抽象类，用于定义装饰者和被装饰者的共同接口。
> 2. 具体组件（Concrete Component）：实现了抽象组件接口，是被装饰者的原始对象，可以动态地添加功能。
> 3. 抽象装饰者（Decorator）：实现了抽象组件接口，并持有一个指向抽象组件的引用，在其中可以动态地添加额外的功能。
> 4. 具体装饰者（Concrete Decorator）：继承自抽象装饰者，实现了具体的装饰逻辑，对原始对象进行装饰。
>

### 代理模式（Proxy Pattern）
为其他对象提供一种代理以控制对这个对象的访问。

> 代理模式（Proxy Pattern）是一种结构型设计模式，目的是控制对对象的访问。代理模式可以为其他对象提供一个替代或占位符，以控制对这个对象的访问。  
通过代理模式，可以实现对真实主题的访问控制、延迟加载、日志记录等功能。代理模式有助于提高系统的安全性、性能和可维护性。
>

> 在代理模式中，有三种主要角色：
>
> 1. 抽象主题（Subject）：定义了代理类和真实主题的共同接口，客户端通过这个接口访问真实主题。
> 2. 真实主题（Real Subject）：实现了抽象主题接口，是代理所代表的真实对象。
> 3. 代理（Proxy）：包含一个指向真实主题的引用，并且实现了抽象主题接口。代理可以在调用真实主题之前或之后执行额外的操作。
>

> 可分为静态代理、动态代理和 CGLib 代理。它们的主要区别在于代理对象的创建方式、使用的技术和灵活性。
>

#### 1. **静态代理（Static Proxy）**
+ **定义**：静态代理是通过手动创建代理类来实现的，代理类和目标类之间是静态的（编译时就确定了）。在静态代理中，代理类需要和目标类实现相同的接口，并且在代理类中委托目标类的具体实现。
+ **实现方式**：
    - 代理类在编译时就已经存在，通常手动编写。
    - 代理类会持有目标类的引用，并在代理方法中调用目标类的对应方法。
+ **优点**：
    - 实现简单，易于理解。
    - 适合一些简单的场景。
+ **缺点**：
    - 每个目标类都需要手动编写一个代理类，代码重复。
    - 不具备灵活性，代理类和目标类的绑定是在编译时确定的，不支持动态扩展。

#### 2. **动态代理（Dynamic Proxy）**
+ **定义**：动态代理是指在运行时动态生成代理对象，它不需要手动编写代理类，而是通过 Java 提供的 `java.lang.reflect.Proxy` 类来动态创建代理对象。动态代理通过反射机制生成代理类，并且可以在运行时绑定目标对象。
+ **实现方式**：
    - 使用 `Proxy` 类和 `InvocationHandler` 接口来创建代理类。代理对象不需要实现接口，只要目标类实现了接口。
    - 代理对象会在调用目标方法时通过反射机制进行处理，通常会执行一些额外的逻辑（如日志、权限检查等）再调用目标方法。
+ **优点**：
    - 动态代理的代理类是运行时生成的，不需要提前写好代理类。
    - 更加灵活，能够在运行时动态改变代理逻辑。
+ **缺点**：
    - 只能代理实现了接口的类，不能代理没有接口的类。

#### 3. **CGLib 代理（CGLib Proxy）**
+ **定义**：CGLib（Code Generation Library）代理是基于继承方式的动态代理，不要求目标对象必须实现接口。CGLib 使用字节码技术动态生成目标类的子类，并通过方法拦截器（`MethodInterceptor`）来实现代理逻辑。
+ **实现方式**：
    - CGLib 通过继承的方式动态生成代理类，目标类的所有方法都会被代理，并且可以在其中添加额外的逻辑。
    - 它通过 `Enhancer` 类来生成代理类，并使用 `MethodInterceptor` 来拦截方法调用。
+ **优点**：
    - 不需要目标类实现接口，可以对普通类进行代理。
    - 灵活性强，可以拦截所有方法。
+ **缺点**：
    - 生成代理类的过程相对复杂，性能上可能会有一些开销。
    - 不能代理 `final` 类和 `final` 方法，因为 CGLib 通过继承生成代理类，而 `final` 修饰的类和方法不能被继承。

#### 总结
| 特性 | 静态代理 | 动态代理 | CGLib 代理 |
| --- | --- | --- | --- |
| 代理类生成时机 | 编译时静态生成 | 运行时动态生成 | 运行时动态生成 |
| 是否需要实现接口 | 需要实现接口 | 需要实现接口（Java 动态代理只支持接口） | 不需要实现接口 |
| 代理对象创建方式 | 手动编写代理类 | `Proxy.newProxyInstance()` | 使用 CGLib 的 `Enhancer` 类生成 |
| 是否支持代理普通类 | 不支持 | 不支持 | 支持 |
| 是否支持代理 `final` 类/方法 | 支持 | 支持（Java 动态代理不能代理 `final` 类） | 不支持 `final` 类/方法 |
| 灵活性 | 低 | 高 | 高 |


+ **静态代理**：适用于简单的场景，代码量较大且不灵活。
+ **动态代理**：适用于接口类型的代理，灵活且能够在运行时动态生成代理对象。
+ **CGLib 代理**：适用于没有接口的类，灵活且能处理普通类的代理，但不能代理 `final` 类或方法。

### 组合模式（Composite Pattern）
将对象组合成树形结构以表示"部分-整体"的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

> 组合模式使得客户端可以统一处理单个对象和对象组合，从而使得组合对象与单个对象具有一致的行为。在组合模式中，有两种主要类型的对象：叶子节点（Leaf）和组合节点（Composite）。叶子节点表示树的最底层节点，它没有子节点，而组合节点可以包含子节点，形成树形结构。
>

### 外观模式（Facade Pattern）
为子系统中的一组接口提供一个统一的接口，使得子系统更容易使用。

> 外观模式（Facade Pattern）是一种结构型[设计模式](https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020)，它提供了一个统一的接口，用来访问子系统中的一群接口。外观模式隐藏了子系统的复杂性，为客户端提供了一个简单的接口，使得客户端不需要了解子系统的具体实现细节。
>

> 外观模式通常包含以下角色：
>
> 1. 外观（Facade）：外观类是客户端访问子系统的入口，它封装了子系统的复杂性，提供了简单的接口供客户端调用。
> 2. 子系统（SubSystem）：子系统包含了一组类，实现了子系统的功能。客户端通过外观类与子系统进行交互。
>

### 亨元模式（Flyweight Pattern）
共享对象以减少内存使用或提高性能。

> 旨在减少系统中相似对象的数量，从而提高系统的性能和减少内存占用。享元模式通过共享相同的对象实例来减少对象的创建，适用于需要创建大量相似对象的场景。
>

> 在享元模式中，有两种关键的角色：
>
> 1. 享元工厂（Flyweight Factory）：负责创建和管理享元对象，通常实现为工厂模式。享元工厂可以维护一个享元池（Flyweight Pool），用于存储共享的享元对象。
> 2. 享元对象（Flyweight）：包含内部状态和外部状态，内部状态是可以共享的部分，而外部状态是不可以共享的部分。享元对象通常是不可变的。
>

## 创建型模式（5）：创建对象
创建型模式主要用于处理对象的创建过程，它将对象的创建和使用分离，使得系统更加灵活和可扩展。

### 工厂方法模式（Factory Pattern）
定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。

#### 简单工厂模式
由一个工厂类根据传入的参数决定创建哪一种产品类的实例。客户端只需要传入一个参数，无需关心具体的实例化过程。

#### 工厂方法模式
定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

### 抽象工厂模式（Abstract Factory Pattern）
提供一个接口，用于创建一系列相关或相互依赖的对象，而不需要指定具体的类。

<font style="color:rgb(51, 51, 51);">通常会定义一个抽象工厂接口，其中包含多个抽象的工厂方法，每个工厂方法用于创建一种产品。抽象工厂模式适合于需要创建一系列相关或相互依赖的对象，并且需要在运行时切换不同产品族的情况。它也符合开闭原则，对修改关闭、对扩展开放。产品组选抽象工厂。</font>

### 单例模式（Singleton Pattern）
确保一个类只有一个实例，并提供一个全局访问点。

#### 饿汉模式
示例中，静态变量 `instance` 在类加载时就被初始化，并且通过 `getInstance()` 方法获取单例对象的时候，直接返回该静态变量的实例。饿汉模式简单易用，线程安全，但可能会导致资源浪费。

#### 饱汉模式
示例中，通过双重检查锁的方式保证了在多线程环境下获取单例对象的线程安全性。首先检查是否已经创建了单例对象，如果没有则进入同步块，在同步块内再次检查是否已经创建了单例对象，如果没有则创建单例对象。饱汉模式延迟了单例对象的创建时间，节约了资源并提高了性能，但需要考虑多线程环境下的线程安全性。

#### 静态嵌套类单例模式
常见且推荐的单例模式实现方式，结合了懒加载（节约资源）和线程安全（单例对象唯一）的优点，当然还有代码简单。

示例中，Singleton 类的私有静态内部类 SingletonHolder 中包含了一个静态 final 的 Singleton 实例，利用类加载的特性保证了线程安全的创建单例对象。当调用 Singleton.getInstance() 方法时，会首次加载 SingletonHolder 类，并创建 Singleton 实例，保证了懒加载的效果。

### 建造者模式（Builder Pattern）
将一个复杂对象的构建过程和表示分离，使得同样的构建过程可以创建不同的表示。

建造者模式通过一个指挥者（Director）和多个建造者（Builder）来创建对象，以简化对象的构建过程。

我们代码中最常用的应该就是Lombok 中使用 @Builder 注解来实现建造者模式。

建造者模式通常包含以下几个角色：

1. 产品（Product）：表示被构建的复杂对象。
2. 抽象建造者（Builder）：定义构建产品各个部件的抽象接口。
3. 具体建造者（Concrete Builder）：实现抽象建造者接口，负责实际构建产品的各个部件。
4. 指挥者（Director）：负责调用具体建造者来构建产品对象，并定义构建的顺序和流程。

建造者模式通过抽象建造者接口、具体建造者类和指挥者来实现对象的构建过程。具体建造者类负责构建产品的各个部件，指挥者负责调用具体建造者来构建产品对象。客户端通过指挥者来构建不同的产品对象，而不需要直接与具体建造者类交互。

建造者模式适用于构建复杂对象，且构建过程需要独立于其表示。它可以灵活地构建不同的产品对象，而不需要知道产品的具体构建细节。建造者模式也符合单一职责原则，每个具体建造者只负责构建一个产品的各个部件。

### 原型模式（Prototype Pattern）
通过复制现有对象来创建新对象，而不是通过实例化。

它允许通过复制现有对象来创建新对象，而无需显式地使用构造函数。

核心概念：

1. 原型接口（Prototype）：定义了克隆方法的接口，所有实现该接口的类都需要实现克隆方法。
2. 具体原型类（ConcretePrototype）：实现了原型接口的具体类，负责实现克隆方法。
3. 客户端（Client）：创建新对象时，通过原型对象复制来获得新对象。

## 行为型模式（11）：运行程序
行为型设计模式主要关注对象之间的通信和职责分配，描述了对象之间的相互作用和责任分配方式。

### 责任链模式（Chain of Responsibility Pattern）
将请求的发送者和接受者解耦，使多个对象都有机会处理这个请求。

> 责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，它允许多个对象在链式结构中处理请求，而不需要明确指定接收请求的对象。责任链模式将请求沿着处理链传递，直到有一个对象能够处理请求为止。
>

> 在责任链模式中，通常包含以下角色：
>
> 1. 抽象处理者（Handler）：定义了一个处理请求的接口，通常包含一个指向下一个处理者的引用。
> 2. 具体处理者（Concrete Handler）：实现了抽象处理者接口，负责处理请求，并决定是否将请求传递给下一个处理者。
>

### 命令模式（Command Pattern）
将请求封装成一个对象，从而可以用不同的请求对客户端进行参数化。

> 请求封装为对象，从而允许参数化客户端操作，并支持将请求排队、记录日志、撤销操作等功能。命令模式将请求发送者和接收者解耦，使得请求发送者不需要知道接收者的具体实现。
>

> 在命令模式中，通常包含以下角色：
>
> 1. 命令接口（Command）：声明了执行命令的方法，通常包含一个 execute 方法。
> 2. 具体命令（Concrete Command）：实现了命令接口，负责执行具体的命令操作。
> 3. 接收者（Receiver）：执行命令的对象。
> 4. 调用者（Invoker）：负责调用命令来执行请求。
> 5. 客户端（Client）：创建具体命令对象，并设置接收者。
>

### 解释器模式（Interpreter Pattern）
用于定义一种语言的文法，并且解释该语言中的句子，该模式通常用于解决一些重复出现的问题。

> 解释器模式是一种行为设计模式，它定义了一种语言文法的表示，并且定义了解释器来解释这种语言中的语句。解释器模式通常用于解释实际问题的特定领域，如编译器、正则表达式等。
>

> 在解释器模式中，通常包含以下几个角色：
>
> 1. **AbstractExpression（抽象表达式）**：声明一个抽象的解释操作，所有具体表达式都要实现这个接口。
> 2. **TerminalExpression（终结符表达式）**：实现了抽象表达式接口，表示语言中的终结符（最小的语法单位）。
> 3. **NonterminalExpression（非终结符表达式）**：实现了抽象表达式接口，表示语言中的非终结符。
> 4. **Context（上下文）**：包含解释器之外的一些全局信息。
>

### 迭代器模式（Iterator Pattern）
提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部表示。

> 迭代器模式（Iterator Pattern）是一种行为型设计模式，提供了一种顺序访问集合对象元素的方法，而又不暴露集合的内部表示。迭代器模式让客户端可以访问集合对象的元素，而不需要了解集合的内部结构。
>

> 在迭代器模式中，通常包含以下角色：
>
> 1. 迭代器（Iterator）：定义了访问和遍历元素的接口。
> 2. 具体迭代器（Concrete Iterator）：实现了迭代器接口，负责对集合进行遍历。
> 3. 聚合对象（Aggregate）：定义了创建迭代器的接口。
> 4. 具体聚合对象（Concrete Aggregate）：实现了聚合对象接口，返回一个具体的迭代器。
>

### 中介者模式（Mediator Pattern）
用一个中介对象来封装一系列的对象交互。

> 中介者模式是一种行为设计模式，它允许对象之间通过一个中介者对象来进行通信，而不是直接相互引用。这种模式有助于减少对象之间的耦合，提高系统的可维护性和可扩展性。
>

> 在中介者模式中，通常有以下几个角色：
>
> 1. **Mediator（中介者）**：定义一个接口用于与各个同事对象通信。中介者通常包含一个或多个方法，用于处理各个同事对象之间的通信。
> 2. **ConcreteMediator（具体中介者）**：实现中介者接口，负责协调各个同事对象的行为。
> 3. **Colleague（同事）**：每个具体同事对象都知道中介者对象，并通过中介者对象来通信。
> 4. **ConcreteColleague（具体同事）**：实现同事接口，每个具体同事对象都包含一些自身的行为，同时需要与其他同事对象协作。
>

### 备忘录模式（Memento Pattern）
在不破坏封装的前提下捕获一个对象的内部状态，并在需要时恢复。

> 备忘录模式是一种行为设计模式，它允许在不破坏封装的前提下捕获并恢复对象的内部状态。备忘录模式通常用于需要保存和恢复对象状态的场景，例如撤销操作、历史记录等。
>

> 在备忘录模式中，通常包含以下几个角色：
>
> 1. **Originator（原发器）**：负责创建一个备忘录对象，并可以使用备忘录对象恢复自身状态。
> 2. **Memento（备忘录）**：存储原发器对象的内部状态，可以包含原发器需要保存的状态信息。
> 3. **Caretaker（负责人）**：负责保存备忘录对象，但不处理或检查备忘录的内容。
>

### 观察者模式（Observer Pattern）
定义了对象之间的一对多依赖关系，当一个对象改变状态时，所有依赖它的对象都会收到通知并自动更新。

> 观察者模式（Observer Pattern）是一种行为设计模式，它定义了一种一对多的依赖关系，使得当一个对象的状态发生变化时，所有依赖于它的对象都会收到通知并自动更新。观察者模式实现了对象之间的松耦合，让主题对象和观察者对象可以独立变化。
>

> 在观察者模式中，通常包含以下角色：
>
> 1. 主题（Subject）：也称为被观察者，维护一组观察者对象，提供注册和删除观察者的方法，以及通知观察者的方法。
> 2. 观察者（Observer）：定义了一个更新接口，用于接收主题的通知并进行相应的更新操作。
> 3. 具体主题（Concrete Subject）：实现了主题接口，维护状态变化并在状态变化时通知观察者。
> 4. 具体观察者（Concrete Observer）：实现了观察者接口，当接收到主题的通知时会执行相应的更新操作。
>

### 状态模式（State Pattern）
允许对象在其内部状态改变时改变它的行为。

> 状态模式是一种行为设计模式，它允许对象在内部状态改变时改变其行为。在状态模式中，对象的行为取决于其内部状态，而不是取决于方法调用。
>

> 在状态模式中，通常包含以下几个角色：
>
> 1. **Context（环境）**：定义客户端感兴趣的接口，维护一个具体状态的实例，并将请求委托给当前状态对象来处理。
> 2. **State（状态接口）**：定义一个接口，封装与Context的一个特定状态相关的行为。
> 3. **ConcreteState（具体状态）**：每个具体状态实现State接口，提供与该状态相关的行为。
>

### 策略模式（Strategy Pattern）
定义一系列算法，封装每个算法，并使它们可以互相替换。

> 策略模式（Strategy Pattern）是为一种行型[设计模式](https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020)，它定义了一系列算法，将每个算法封装起来，并使它们可以互相替换。策略模式可以让算法独立于使用它的客户端而变化，从而提高了灵活性和可维护性。
>

> 在策略模式中，通常包含以下角色：
>
> 1. 环境(Context)：持有一个策略对象的引用，负责调用具体的策略算法。
> 2. 抽象策略(Strategy)：定义了一个算法的接口，所有具体策略类都要实现这个接口。
> 3. 具体策略(Concrete Strategy)：具体的算法实现，实现了抽象策略接口。
>

### 模板方法模式（Template Method Pattern）
定义一个算法的框架，将具体步骤延迟到子类中实现。

> 模板方法模式（Template Method Pattern）是一种行为设计模式，它定义了一个算法的骨架，将算法中的某些步骤延迟到子类中实现。模板方法模式通过将通用的算法步骤放在父类中，而将特定实现延迟到子类中，从而实现代码复用和减少重复。
>

> 在模板方法模式中，通常包含以下角色：
>
> 1. 抽象模板（Abstract Template）：定义了一个算法的骨架，其中包含了算法执行的步骤，有些步骤可以是抽象方法，由子类实现。
> 2. 具体模板（Concrete Template）：实现了抽象模板中的抽象方法，完成算法的具体步骤。
> 3. 模板方法（Template Method）：定义了算法的具体步骤，包含了对抽象方法的调用。
>

### 访问者模式（Visitor Pattern）
将算法与对象结构分离，使得可以在不改变这些对象的前提下定义新的操作。

> 访问者模式是一种行为设计模式，它允许你在不改变数据结构的前提下定义对数据结构中元素的新操作。访问者模式将数据结构和数据操作分离，使得数据结构可以独立变化而不影响数据操作。
>

> 在访问者模式中，通常有以下几个角色：
>
> 1. **Visitor（访问者）**：定义了对数据结构中每个元素的访问操作，可以根据需要定义多个不同的访问者。
> 2. **ConcreteVisitor（具体访问者）**：实现了Visitor接口中定义的具体访问操作，针对数据结构中的不同元素进行具体操作。
> 3. **Element（元素）**：定义了接受访问者访问的接口，可以是具体的数据结构或对象。
> 4. **ConcreteElement（具体元素）**：实现了Element接口，表示数据结构中的具体元素，通常会有accept方法用于接受访问者的访问。
> 5. **ObjectStructure（对象结构）**：维护一个元素的集合，并提供访问者访问元素的接口。
>

通过访问者模式，我们可以在不改变元素数据结构的情况下定义新的操作，从而实现对数据结构的扩展和灵活性。



